# v0.2.0 Enhanced Visualization Module Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a comprehensive visualization module for ScpTensor with Scanpy-style functions, SciencePlots integration, and native multi-panel layouts.

**Architecture:** Modular design with base components (style, data extraction, missing value handling) and high-level recipe functions organized by category (embedding, feature, matrix, differential, QC, statistics). All functions follow consistent API: `plot_xxx(container, layer, groupby, ...)`.

**Tech Stack:** Python 3.11+, Matplotlib, SciencePlots, NumPy, SciPy, Polars

---

## Phase 1: Infrastructure (P0)

### Task 1.1: Extend Style Manager

**Files:**
- Modify: `scptensor/viz/base/style.py`
- Test: `tests/test_viz/test_base/test_style.py`

**Step 1: Write failing tests**

Create `tests/test_viz/test_base/test_style.py`:

```python
import pytest
import matplotlib.pyplot as plt
from scptensor.viz.base.style import PlotStyle

def test_apply_default_style():
    """Test applying default science style"""
    PlotStyle.apply_style()
    assert plt.rcParams["axes.unicode_minus"] == False
    assert "science" in plt.style.available

def test_apply_custom_theme():
    """Test applying specific theme"""
    PlotStyle.apply_style(theme="ieee")
    assert "ieee" in plt.style.available

def test_get_colormap_default():
    """Test getting default colormap for purpose"""
    cmap = PlotStyle.get_colormap("expression")
    assert cmap == "viridis"

def test_get_colormap_custom():
    """Test custom colormap override"""
    cmap = PlotStyle.get_colormap("expression", custom="plasma")
    assert cmap == "plasma"

def test_get_colormap_missing():
    """Test missing value colormap"""
    cmap = PlotStyle.get_colormap("missing")
    assert cmap == "gray_r"

def test_invalid_purpose_raises():
    """Test invalid purpose raises error"""
    with pytest.raises(ValueError):
        PlotStyle.get_colormap("invalid_purpose")
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_base/test_style.py -v
```
Expected: FAIL - module doesn't have required functions yet

**Step 3: Implement in `scptensor/viz/base/style.py`**

```python
"""Extended style manager with SciencePlots integration."""

from typing import Literal

# Predefined themes
THEMES = {
    "science": ["science", "no-latex"],
    "science_grid": ["science", "grid", "no-latex"],
    "ieee": ["ieee", "no-latex"],
    "nature": ["nature", "no-latex"],
}

# Proteomics color schemes (distinct from RNA-seq)
CMAP_PROTEOMICS = {
    "expression": "viridis",
    "missing": "gray_r",
    "logfc": "RdBu_r",
    "significance": "plasma",
    "clusters": "tab20",
}

_VALID_PURPOSES = set(CMAP_PROTEOMICS.keys())


class PlotStyle:
    """Unified style management with SciencePlots integration."""

    @staticmethod
    def apply_style(theme: Literal["science", "science_grid", "ieee", "nature"] = "science", dpi: int = 300) -> None:
        """
        Apply plotting style.

        Parameters
        ----------
        theme : str
            Theme name from THEMES
        dpi : int
            DPI for saved figures
        """
        import matplotlib.pyplot as plt

        if theme not in THEMES:
            raise ValueError(f"Unknown theme: {theme}. Choose from {list(THEMES.keys())}")

        styles = THEMES[theme]
        plt.style.use(styles)
        plt.rcParams["figure.dpi"] = dpi
        plt.rcParams["savefig.dpi"] = dpi
        plt.rcParams["axes.unicode_minus"] = False

    @staticmethod
    def get_colormap(purpose: str, custom: str | None = None) -> str:
        """
        Get color scheme for specific purpose.

        Parameters
        ----------
        purpose : str
            One of: expression, missing, logfc, significance, clusters
        custom : str or None
            Custom colormap name (overrides purpose)

        Returns
        -------
        str
            Colormap name
        """
        if custom is not None:
            return custom
        if purpose not in _VALID_PURPOSES:
            raise ValueError(f"Unknown purpose: {purpose}. Choose from {_VALID_PURPOSES}")
        return CMAP_PROTEOMICS[purpose]
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_base/test_style.py -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/base/style.py tests/test_viz/test_base/test_style.py
git commit -m "feat(viz): extend PlotStyle with themes and proteomics colormaps"
```

---

### Task 1.2: Multi-Panel Layout Manager

**Files:**
- Create: `scptensor/viz/base/multi_panel.py`
- Test: `tests/test_viz/test_base/test_multi_panel.py`

**Step 1: Write failing tests**

Create `tests/test_viz/test_base/test_multi_panel.py`:

```python
import pytest
import matplotlib.pyplot as plt
import numpy as np
from scptensor.viz.base.multi_panel import PanelLayout

def test_panel_layout_init():
    """Test PanelLayout initialization"""
    layout = PanelLayout(figsize=(10, 8))
    assert layout.figsize == (10, 8)
    assert layout.grid is None

def test_panel_layout_with_grid():
    """Test PanelLayout with explicit grid"""
    layout = PanelLayout(figsize=(12, 8), grid=(2, 2))
    assert layout.grid == (2, 2)

def test_add_panel():
    """Test adding a panel"""
    layout = PanelLayout(figsize=(10, 8), grid=(2, 2))
    ax = layout.add_panel(0, lambda ax: ax.plot([1, 2, 3]))
    assert ax is not None

def test_finalize_creates_figure():
    """Test finalize creates figure"""
    layout = PanelLayout(figsize=(10, 8), grid=(2, 2))
    layout.add_panel(0, lambda ax: ax.set_title("Panel 0"))
    fig = layout.finalize()
    assert isinstance(fig, plt.Figure)

def test_shared_colorbar():
    """Test shared colorbar"""
    layout = PanelLayout(figsize=(10, 8))
    im = np.random.rand(10, 10)
    layout.add_panel(0, lambda ax: ax.imshow(im, cmap="viridis"))
    layout.add_colorbar(position="right")
    layout.finalize()
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_base/test_multi_panel.py -v
```
Expected: FAIL - module doesn't exist

**Step 3: Implement `scptensor/viz/base/multi_panel.py`**

```python
"""Multi-panel layout manager for combined plots."""

from typing import Callable, Any
import matplotlib.pyplot as plt
from matplotlib.figure import Figure


class PanelLayout:
    """Multi-panel combined plot layout manager."""

    def __init__(self, figsize: tuple[float, float] = (12, 8), grid: tuple[int, int] | None = None) -> None:
        """
        Initialize panel layout.

        Parameters
        ----------
        figsize : tuple
            Overall figure size (width, height) in inches
        grid : tuple or None
            (n_rows, n_cols) or auto-compute
        """
        self.figsize = figsize
        self.grid = grid
        self._n_panels = 0
        self._figure: Figure | None = None
        self._axes: list = []
        self._colorbar_sources: list = []
        self._legend_elements: list = []

    def _create_figure(self) -> None:
        """Create figure and subplots if not exists."""
        if self._figure is None:
            if self.grid is not None:
                n_rows, n_cols = self.grid
            else:
                # Auto-compute grid based on panel count
                import math
                n_cols = math.ceil(math.sqrt(self._n_panels)) if self._n_panels > 0 else 1
                n_rows = math.ceil(self._n_panels / n_cols)
                self.grid = (n_rows, n_cols)

            self._figure, self._axes = plt.subplots(
                self.grid[0], self.grid[1],
                figsize=self.figsize,
                squeeze=False
            )
            self._axes = self._axes.flatten()

    def add_panel(
        self,
        position: int | tuple[int, int],
        plot_func: Callable[[plt.Axes], Any],
        **kwargs
    ) -> plt.Axes:
        """
        Add subplot panel.

        Parameters
        ----------
        position : int or tuple
            Panel index or (row, col) position
        plot_func : callable
            Function that takes an Axes and plots on it
        **kwargs
            Additional arguments passed to plot_func

        Returns
        -------
        Axes
            The axes object
        """
        self._n_panels += 1
        self._create_figure()

        if isinstance(position, tuple):
            idx = position[0] * self.grid[1] + position[1]
        else:
            idx = position

        ax = self._axes[idx]
        result = plot_func(ax, **kwargs)

        # Store image for potential colorbar
        if hasattr(result, 'get_cmap'):
            self._colorbar_sources.append((ax, result))

        return ax

    def add_legend(
        self,
        position: str = "right",
        labels: list[str] | None = None,
        **kwargs
    ) -> None:
        """
        Add shared legend across panels.

        Parameters
        ----------
        position : str
            Legend position ('right', 'bottom', 'outside')
        labels : list or None
            Legend labels
        **kwargs
            Additional legend arguments
        """
        self._legend_elements.append({
            "position": position,
            "labels": labels,
            "kwargs": kwargs
        })

    def add_colorbar(self, position: str = "right", label: str = "") -> None:
        """
        Add shared colorbar across panels.

        Parameters
        ----------
        position : str
            Colorbar position
        label : str
            Colorbar label
        """
        if not self._colorbar_sources:
            return

        # Use first colorbar source
        ax, mappable = self._colorbar_sources[0]
        cbar = self._figure.colorbar(mappable, ax=ax, label=label)

    def finalize(self, tight: bool = True) -> Figure:
        """
        Finalize layout and adjust spacing.

        Parameters
        ----------
        tight : bool
            Use tight_layout

        Returns
        -------
        Figure
            The finalized figure
        """
        if tight:
            self._figure.tight_layout()

        # Handle legends
        for legend_spec in self._legend_elements:
            # Add legend to first axes
            self._axes[0].legend(
                labels=legend_spec["labels"],
                loc="best" if legend_spec["position"] != "outside" else "center left bbox_to_anchor",
                **legend_spec["kwargs"]
            )

        return self._figure

    @property
    def figure(self) -> Figure:
        """Get the figure."""
        if self._figure is None:
            self._create_figure()
        return self._figure

    @property
    def axes(self) -> list:
        """Get all axes."""
        if not self._axes:
            self._create_figure()
        return self._axes
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_base/test_multi_panel.py -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/base/multi_panel.py tests/test_viz/test_base/test_multi_panel.py
git commit -m "feat(viz): add PanelLayout for multi-panel plots"
```

---

### Task 1.3: Data Extractor

**Files:**
- Create: `scptensor/viz/base/data_extractor.py`
- Test: `tests/test_viz/test_base/test_data_extractor.py`

**Step 1: Write failing tests**

```python
# tests/test_viz/test_base/test_data_extractor.py
import pytest
import numpy as np
from scipy import sparse
from scptensor import ScpContainer, Assay, ScpMatrix
from scptensor.viz.base.data_extractor import DataExtractor

@pytest.fixture
def test_container():
    """Create test container with layers."""
    X_raw = np.random.rand(100, 50) * 10
    M_raw = np.zeros_like(X_raw, dtype=int)
    M_raw[X_raw < 2] = 1  # Some missing values

    container = ScpContainer(n_samples=100)
    container.obs["cluster"] = np.random.choice(["A", "B", "C"], 100)
    container.obs["batch"] = np.random.choice(["batch1", "batch2"], 100)

    assay = Assay(n_features=50)
    assay.var["protein"] = [f"P{i}" for i in range(50)]
    assay.layers["raw"] = ScpMatrix(X=X_raw, M=M_raw)
    assay.layers["normalized"] = ScpMatrix(X=np.log1p(X_raw), M=M_raw)

    container.assays["proteins"] = assay
    return container

def test_get_expression_matrix_dense(test_container):
    """Test extracting dense expression matrix."""
    X, obs, var = DataExtractor.get_expression_matrix(
        test_container, "proteins", "normalized"
    )
    assert X.shape == (100, 50)
    assert isinstance(X, np.ndarray)

def test_get_expression_matrix_sparse(test_container):
    """Test extracting sparse expression matrix."""
    X_sparse = sparse.csr_matrix(np.random.rand(100, 50) * 10)
    test_container.assays["proteins"].layers["sparse"] = ScpMatrix(X=X_sparse, M=np.zeros_like(X_sparse, dtype=int))

    X, _, _ = DataExtractor.get_expression_matrix(test_container, "proteins", "sparse")
    assert sparse.issparse(X) or isinstance(X, np.ndarray)

def test_get_expression_matrix_with_features(test_container):
    """Test extracting subset of features."""
    features = ["P0", "P1", "P2"]
    X, obs, var = DataExtractor.get_expression_matrix(
        test_container, "proteins", "normalized", var_names=features
    )
    assert X.shape == (100, 3)

def test_get_group_data(test_container):
    """Test extracting group information."""
    groups = DataExtractor.get_group_data(test_container, "cluster")
    assert groups is not None
    assert len(groups) == 100

def test_handle_missing_values_separate():
    """Test separating missing values."""
    X = np.array([[1, 2, 0], [4, 0, 6]])
    M = np.array([[0, 0, 1], [0, 2, 0]])  # 1=MBR, 2=LOD

    X_valid, X_missing, M_types = DataExtractor.handle_missing_values(X, M, method="separate")
    assert X_valid.shape[0] == 3  # 3 valid values
    assert X_missing.shape[0] == 2  # 2 missing values
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_base/test_data_extractor.py -v
```
Expected: FAIL

**Step 3: Implement `scptensor/viz/base/data_extractor.py`**

```python
"""Data extraction utilities for visualization."""

from typing import Literal
import numpy as np
from scipy import sparse
from scptensor import ScpContainer


class DataExtractor:
    """Extract plotting data from ScpContainer with unified handling."""

    @staticmethod
    def get_expression_matrix(
        container: ScpContainer,
        assay_name: str,
        layer: str,
        var_names: list[str] | None = None,
        samples: list[str] | None = None,
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Get expression matrix with metadata.

        Parameters
        ----------
        container : ScpContainer
            Input container
        assay_name : str
            Assay name
        layer : str
            Layer name
        var_names : list or None
            Feature names to extract (None = all)
        samples : list or None
            Sample names to extract (None = all)

        Returns
        -------
        X : ndarray
            Expression matrix (n_samples x n_features)
        obs : ndarray
            Sample metadata
        var : ndarray
            Feature metadata
        """
        assay = container.assays[assay_name]
        scpmatrix = assay.layers[layer]

        X = scpmatrix.X
        M = scpmatrix.M if scpmatrix.M is not None else np.zeros_like(X, dtype=int)

        # Filter samples
        if samples is not None:
            sample_idx = [i for i, s in enumerate(container.obs["sample_id"]) if s in samples]
            X = X[sample_idx]
            M = M[sample_idx]
            obs = container.obs[sample_idx]
        else:
            obs = container.obs

        # Filter features
        if var_names is not None:
            feature_idx = [i for i, v in enumerate(assay.var["protein"]) if v in var_names]
            X = X[:, feature_idx]
            M = M[:, feature_idx]
            var = assay.var[feature_idx]
        else:
            var = assay.var

        return X, obs.to_numpy(), var.to_numpy()

    @staticmethod
    def get_group_data(
        container: ScpContainer,
        groupby: str,
    ) -> np.ndarray:
        """
        Get grouping information.

        Parameters
        ----------
        container : ScpContainer
            Input container
        groupby : str
            Column name in obs

        Returns
        -------
        ndarray
            Group labels for each sample
        """
        if groupby not in container.obs.columns:
            raise ValueError(f"Column '{groupby}' not found in obs")
        return container.obs[groupby].to_numpy()

    @staticmethod
    def handle_missing_values(
        X: np.ndarray,
        M: np.ndarray,
        method: Literal["separate", "transparent", "imputed"] = "separate"
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Handle missing values for visualization.

        Parameters
        ----------
        X : ndarray
            Expression matrix
        M : ndarray
            Mask matrix (0=valid, 1=MBR, 2=LOD, 3=filtered)
        method : str
            - 'separate': Return separate arrays for valid/missing
            - 'transparent': Return X with nan for missing
            - 'imputed': Return X as-is (assume already imputed)

        Returns
        -------
        X_valid : ndarray
            Valid values
        X_missing : ndarray
            Missing values (if method='separate')
        M_types : ndarray
            Missing value types
        """
        if method == "imputed":
            return X, np.array([]), np.array([])

        valid_mask = (M == 0)
        missing_mask = (M > 0)

        if method == "transparent":
            X_result = X.copy().astype(float)
            X_result[missing_mask] = np.nan
            return X_result, np.array([]), M[missing_mask]

        # method == 'separate'
        X_valid = X[valid_mask]
        X_missing = X[missing_mask]
        M_types = M[missing_mask]

        return X_valid, X_missing, M_types
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_base/test_data_extractor.py -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/base/data_extractor.py tests/test_viz/test_base/test_data_extractor.py
git commit -m "feat(viz): add DataExtractor for unified data handling"
```

---

### Task 1.4: Missing Value Handler

**Files:**
- Create: `scptensor/viz/base/missing_value.py`
- Test: `tests/test_viz/test_base/test_missing_value.py`

**Step 1: Write failing tests**

```python
# tests/test_viz/test_base/test_missing_value.py
import pytest
import matplotlib.pyplot as plt
import numpy as np
from scptensor.viz.base.missing_value import MissingValueHandler

def test_missing_colors_defined():
    """Test missing value colors are defined."""
    assert "missing" in MissingValueHandler.MISSING_COLORS
    assert 1 in MissingValueHandler.MISSING_COLORS  # MBR

def test_separate_mask():
    """Test separating valid and missing values."""
    X = np.array([[1, 2, 3], [4, 5, 6]])
    M = np.array([[0, 1, 0], [2, 0, 3]])

    X_valid, X_missing, M_missing = MissingValueHandler.separate_mask(X, M)
    assert len(X_valid) == 3
    assert len(X_missing) == 3
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_base/test_missing_value.py -v
```
Expected: FAIL

**Step 3: Implement `scptensor/viz/base/missing_value.py`**

```python
"""Missing value visualization handling."""

from typing import Tuple
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.collections import PathCollection


class MissingValueHandler:
    """Unified missing value visualization handling."""

    # Missing value type colors
    MISSING_COLORS = {
        1: "#d3d3d3",  # MBR - Light gray
        2: "#add8e6",  # LOD - Light blue
        3: "#ffcccb",  # FILTERED - Light red
    }

    @staticmethod
    def separate_mask(
        X: np.ndarray,
        M: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Separate valid and missing values.

        Parameters
        ----------
        X : ndarray
            Data matrix
        M : ndarray
            Mask matrix

        Returns
        -------
        X_valid : ndarray
            Valid values (where M == 0)
        X_missing : ndarray
            Missing values (where M > 0)
        M_types : ndarray
            Missing value types
        """
        valid_mask = (M == 0)
        missing_mask = (M > 0)

        X_valid = X[valid_mask]
        X_missing = X[missing_mask]
        M_types = M[missing_mask]

        return X_valid, X_missing, M_types

    @staticmethod
    def create_overlay_scatter(
        x: np.ndarray,
        y: np.ndarray,
        M: np.ndarray,
        ax: plt.Axes,
        size: float = 5.0,
        alpha: float = 0.8,
        **scatter_kwargs
    ) -> dict:
        """
        Create layered scatter plot with missing values.

        Parameters
        ----------
        x, y : ndarray
            Coordinates
        M : ndarray
            Mask values (0=valid, >0=missing)
        ax : Axes
            Matplotlib axes
        size : float
            Point size
        alpha : float
            Transparency
        **scatter_kwargs
            Additional scatter arguments

        Returns
        -------
        dict
            Dictionary with legend handles
        """
        valid_mask = (M == 0)

        # Plot valid values first
        if valid_mask.sum() > 0:
            ax.scatter(
                x[valid_mask], y[valid_mask],
                s=size, alpha=alpha,
                label="Detected",
                **scatter_kwargs
            )

        # Plot each missing type separately
        handles = {"Detected": True}
        for m_type, color in MissingValueHandler.MISSING_COLORS.items():
            type_mask = (M == m_type)
            if type_mask.sum() > 0:
                ax.scatter(
                    x[type_mask], y[type_mask],
                    s=size, alpha=alpha * 0.7,
                    color=color,
                    label=f"Missing ({m_type})",
                    edgecolors="none",
                )
                handles[f"Missing ({m_type})"] = True

        return handles
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_base/test_missing_value.py -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/base/missing_value.py tests/test_viz/test_base/test_missing_value.py
git commit -m "feat(viz): add MissingValueHandler for overlay visualization"
```

---

### Task 1.5: Validation Module

**Files:**
- Create: `scptensor/viz/base/validation.py`
- Test: `tests/test_viz/test_base/test_validation.py`

**Step 1: Write failing tests**

```python
# tests/test_viz/test_base/test_validation.py
import pytest
import numpy as np
from scptensor import ScpContainer
from scptensor.viz.base.validation import (
    validate_container,
    validate_layer,
    validate_features,
    validate_groupby,
    validate_plot_data,
)
from scptensor.core.exceptions import VisualizationError

def test_validate_container_pass():
    """Test valid container passes."""
    container = ScpContainer(n_samples=10)
    validate_container(container)  # Should not raise

def test_validate_layer_exists():
    """Test existing layer passes."""
    container = ScpContainer(n_samples=10)
    # Add assay with layer
    from scptensor import Assay, ScpMatrix
    assay = Assay(n_features=5)
    assay.layers["raw"] = ScpMatrix(X=np.random.rand(10, 5))
    container.assays["proteins"] = assay
    validate_layer(container, "proteins", "raw")  # Should not raise

def test_validate_layer_missing():
    """Test missing layer raises error."""
    container = ScpContainer(n_samples=10)
    from scptensor import Assay, ScpMatrix
    assay = Assay(n_features=5)
    assay.layers["raw"] = ScpMatrix(X=np.random.rand(10, 5))
    container.assays["proteins"] = assay

    with pytest.raises(VisualizationError):
        validate_layer(container, "proteins", "nonexistent")

def test_validate_plot_data_insufficient():
    """Test insufficient data raises error."""
    with pytest.raises(VisualizationError):
        validate_plot_data(np.array([]), n_min=1)
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_base/test_validation.py -v
```
Expected: FAIL

**Step 3: Implement `scptensor/viz/base/validation.py`**

```python
"""Input validation for visualization functions."""

import numpy as np
from scptensor import ScpContainer
from scptensor.core.exceptions import VisualizationError, LayerNotFoundError


def validate_container(container: ScpContainer) -> None:
    """
    Validate container.

    Parameters
    ----------
    container : ScpContainer
        Input container

    Raises
    ------
    VisualizationError
        If container is invalid
    """
    if container is None:
        raise VisualizationError("Container cannot be None")
    if not isinstance(container, ScpContainer):
        raise VisualizationError(f"Expected ScpContainer, got {type(container)}")


def validate_layer(container: ScpContainer, assay_name: str, layer: str) -> None:
    """
    Validate layer exists.

    Parameters
    ----------
    container : ScpContainer
        Input container
    assay_name : str
        Assay name
    layer : str
        Layer name

    Raises
    ------
    LayerNotFoundError
        If layer doesn't exist
    """
    if assay_name not in container.assays:
        raise VisualizationError(f"Assay '{assay_name}' not found")

    assay = container.assays[assay_name]
    if layer not in assay.layers:
        raise LayerNotFoundError(f"Layer '{layer}' not found in assay '{assay_name}'")


def validate_features(
    container: ScpContainer,
    assay_name: str,
    var_names: list[str]
) -> None:
    """
    Validate feature names exist in var.

    Parameters
    ----------
    container : ScpContainer
        Input container
    assay_name : str
        Assay name
    var_names : list
        Feature names to validate

    Raises
    ------
    VisualizationError
        If features not found
    """
    assay = container.assays[assay_name]
    var_col = "protein" if "protein" in assay.var.columns else assay.var.columns[0]
    available = set(assay.var[var_col].tolist())
    missing = set(var_names) - available

    if missing:
        raise VisualizationError(f"Features not found: {missing}")


def validate_groupby(container: ScpContainer, groupby: str) -> None:
    """
    Validate groupby column exists in obs.

    Parameters
    ----------
    container : ScpContainer
        Input container
    groupby : str
        Column name in obs

    Raises
    ------
    VisualizationError
        If column not found
    """
    if groupby not in container.obs.columns:
        raise VisualizationError(f"Column '{groupby}' not found in obs")


def validate_plot_data(X: np.ndarray, n_min: int = 1) -> None:
    """
    Validate sufficient data for plotting.

    Parameters
    ----------
    X : ndarray
        Data array
    n_min : int
        Minimum required elements

    Raises
    ------
    VisualizationError
        If insufficient data
    """
    if X.size < n_min:
        raise InsufficientDataError(f"Insufficient data: {X.size} < {n_min}")
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_base/test_validation.py -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/base/validation.py tests/test_viz/test_base/test_validation.py
git commit -m "feat(viz): add validation utilities for plotting functions"
```

---

### Task 1.6: Update Base `__init__.py`

**Files:**
- Modify: `scptensor/viz/base/__init__.py`

**Step 1: Update exports**

```python
"""Base visualization components."""

from scptensor.viz.base.style import PlotStyle, THEMES, CMAP_PROTEOMICS
from scptensor.viz.base.multi_panel import PanelLayout
from scptensor.viz.base.data_extractor import DataExtractor
from scptensor.viz.base.missing_value import MissingValueHandler
from scptensor.viz.base.validation import (
    validate_container,
    validate_layer,
    validate_features,
    validate_groupby,
    validate_plot_data,
)

__all__ = [
    "PlotStyle",
    "THEMES",
    "CMAP_PROTEOMICS",
    "PanelLayout",
    "DataExtractor",
    "MissingValueHandler",
    "validate_container",
    "validate_layer",
    "validate_features",
    "validate_groupby",
    "validate_plot_data",
]
```

**Step 2: Commit**

```bash
git add scptensor/viz/base/__init__.py
git commit -m "feat(viz): update base module exports"
```

---

## Phase 2: Embedding Visualization (P1)

### Task 2.1: Generic Scatter Function

**Files:**
- Create: `scptensor/viz/recipes/embedding.py`
- Test: `tests/test_viz/test_recipes/test_embedding.py`

**Step 1: Write failing tests**

```python
# tests/test_viz/test_recipes/test_embedding.py
import pytest
import numpy as np
from scptensor import ScpContainer, Assay, ScpMatrix
from scptensor.viz.recipes.embedding import scatter

@pytest.fixture
def embedding_container():
    """Create container with embedding coordinates."""
    container = ScpContainer(n_samples=100)
    container.obs["cluster"] = np.random.choice(["A", "B", "C"], 100)
    container.obs["umap_1"] = np.random.randn(100)
    container.obs["umap_2"] = np.random.randn(100)

    assay = Assay(n_features=50)
    assay.layers["normalized"] = ScpMatrix(X=np.random.rand(100, 50))
    container.assays["proteins"] = assay
    return container

def test_scatter_basic(embedding_container):
    """Test basic scatter plot."""
    ax = scatter(
        embedding_container,
        layer="normalized",
        basis="umap",
    )
    assert ax is not None

def test_scatter_with_color(embedding_container):
    """Test scatter with color by obs column."""
    ax = scatter(
        embedding_container,
        layer="normalized",
        basis="umap",
        color="cluster",
    )
    assert ax is not None

def test_scatter_with_missing_values():
    """Test scatter shows missing values."""
    container = ScpContainer(n_samples=50)
    container.obs["umap_1"] = np.random.randn(50)
    container.obs["umap_2"] = np.random.randn(50)

    assay = Assay(n_features=20)
    X = np.random.rand(50, 20) * 10
    M = np.zeros_like(X, dtype=int)
    M[X < 2] = 1  # Some missing
    assay.layers["raw"] = ScpMatrix(X=X, M=M)
    container.assays["proteins"] = assay

    ax = scatter(
        container,
        layer="raw",
        basis="umap",
        color="protein_0",
    )
    assert ax is not None
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_recipes/test_embedding.py -v
```
Expected: FAIL

**Step 3: Implement `scptensor/viz/recipes/embedding.py`**

```python
"""Embedding visualization functions."""

from typing import Literal
import numpy as np
import matplotlib.pyplot as plt
from scptensor import ScpContainer
from scptensor.viz.base.style import PlotStyle
from scptensor.viz.base.validation import validate_container, validate_layer
from scptensor.viz.base.data_extractor import DataExtractor
from scptensor.viz.base.missing_value import MissingValueHandler


def scatter(
    container: ScpContainer,
    layer: str,
    basis: str = "umap",
    color: str | list[str] | None = None,
    groupby: str | None = None,
    palette: str | list | None = None,
    size: float = 5.0,
    alpha: float = 0.8,
    use_raw: bool = False,
    show_missing_values: bool = True,
    legend_loc: str = "right margin",
    frameon: bool = True,
    title: str | None = None,
    ax: plt.Axes | None = None,
    **kwargs
) -> plt.Axes:
    """
    Generic scatter plot for any embedding coordinates.

    Parameters
    ----------
    container : ScpContainer
        Input container
    layer : str
        Data layer to use for coloring
    basis : str
        Embedding basis (umap, pca, tsne, or custom obs columns)
    color : str, list, or None
        obs column or feature name to color by
    groupby : str or None
        Column in obs to group by
    palette : str, list, or None
        Color palette
    size : float
        Point size
    alpha : float
        Transparency
    use_raw : bool
        Use raw data for coloring
    show_missing_values : bool
        Show missing values distinctly
    legend_loc : str
        Legend location
    frameon : bool
        Draw frame around plot
    title : str or None
        Plot title
    ax : Axes or None
        Matplotlib axes to plot on
    **kwargs
        Additional arguments passed to scatter

    Returns
    -------
    Axes
        Matplotlib axes
    """
    # Validate inputs
    validate_container(container)
    validate_layer(container, "proteins", layer)

    # Apply style
    PlotStyle.apply_style()

    # Create axes if needed
    if ax is None:
        fig, ax = plt.subplots(figsize=(8, 6))

    # Get embedding coordinates
    if f"{basis}_1" in container.obs.columns and f"{basis}_2" in container.obs.columns:
        x = container.obs[f"{basis}_1"].to_numpy()
        y = container.obs[f"{basis}_2"].to_numpy()
    else:
        raise ValueError(f"Embedding columns '{basis}_1' and '{basis}_2' not found in obs")

    # Determine color values
    if color is None:
        colors = "#1f77b4"  # Default blue
        M = np.zeros(len(x), dtype=int)
    elif color in container.obs.columns:
        # Color by obs column
        colors = container.obs[color].to_numpy()
        M = np.zeros(len(x), dtype=int)
    else:
        # Color by feature - get data and mask
        assay = container.assays["proteins"]
        scpmatrix = assay.layers[layer]
        feature_idx = list(assay.var["protein"]).index(color) if color in assay.var["protein"].tolist() else 0
        colors = scpmatrix.X[:, feature_idx] if scpmatrix.X.ndim > 1 else scpmatrix.X
        M = scpmatrix.M[:, feature_idx] if scpmatrix.M is not None else np.zeros(len(x), dtype=int)

    # Plot
    if show_missing_values and isinstance(colors, np.ndarray) and M.sum() > 0:
        MissingValueHandler.create_overlay_scatter(
            x, y, M, ax, size=size, alpha=alpha,
            c=colors if not isinstance(colors, str) else None,
            **kwargs
        )
    else:
        ax.scatter(x, y, s=size, alpha=alpha, c=colors, **kwargs)

    # Styling
    ax.set_xlabel(f"{basis.upper()}1")
    ax.set_ylabel(f"{basis.upper()}2")
    if not frameon:
        ax.set_frame_on(False)
    if title:
        ax.set_title(title)

    # Legend
    if color and color in container.obs.columns:
        ax.legend(title=color, loc=legend_loc.replace(" margin", ""))

    return ax


def umap(container: ScpContainer, **kwargs) -> plt.Axes:
    """UMAP scatter plot."""
    return scatter(container, basis="umap", **kwargs)


def pca(container: ScpContainer, **kwargs) -> plt.Axes:
    """PCA scatter plot."""
    return scatter(container, basis="pca", **kwargs)


def tsne(container: ScpContainer, **kwargs) -> plt.Axes:
    """t-SNE scatter plot."""
    return scatter(container, basis="tsne", **kwargs)
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_recipes/test_embedding.py -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/recipes/embedding.py tests/test_viz/test_recipes/test_embedding.py
git commit -m "feat(viz): add scatter, umap, pca, tsne functions"
```

---

## Phase 3: Feature Visualization (P1)

### Task 3.1: Dot Plot

**Files:**
- Create: `scptensor/viz/recipes/feature.py`
- Test: `tests/test_viz/test_recipes/test_feature.py`

**Step 1: Write failing tests**

```python
# tests/test_viz/test_recipes/test_feature.py
import pytest
import numpy as np
from scptensor import ScpContainer, Assay, ScpMatrix
from scptensor.viz.recipes.feature import dotplot, violin, stacked_violin

@pytest.fixture
def feature_container():
    """Create container with feature data."""
    container = ScpContainer(n_samples=60)
    container.obs["cluster"] = np.repeat(["A", "B", "C"], 20)

    assay = Assay(n_features=10)
    assay.var["protein"] = [f"P{i}" for i in range(10)]
    X = np.random.rand(60, 10) * 10
    assay.layers["normalized"] = ScpMatrix(X=X)
    container.assays["proteins"] = assay
    return container

def test_dotplot_basic(feature_container):
    """Test basic dot plot."""
    ax = dotplot(
        feature_container,
        layer="normalized",
        var_names=["P0", "P1", "P2"],
        groupby="cluster",
    )
    assert ax is not None
```

**Step 2: Run tests to verify they fail**

```bash
uv run pytest tests/test_viz/test_recipes/test_feature.py::test_dotplot_basic -v
```
Expected: FAIL

**Step 3: Implement dotplot in `scptensor/viz/recipes/feature.py`**

```python
"""Feature visualization functions."""

from typing import Literal
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from scptensor import ScpContainer
from scptensor.viz.base.style import PlotStyle
from scptensor.viz.base.validation import validate_container, validate_layer, validate_features, validate_groupby


def dotplot(
    container: ScpContainer,
    layer: str,
    var_names: list[str],
    groupby: str,
    dendrogram: bool = False,
    log: bool = True,
    cmap: str = "viridis",
    dot_size: float = 5.0,
    standard_scale: Literal["var", "obs"] | None = "var",
    show: bool = True,
    ax: plt.Axes | None = None,
    **kwargs
) -> plt.Axes:
    """
    Dot plot: dot size = expression %, color = mean expression.

    Parameters
    ----------
    container : ScpContainer
        Input container
    layer : str
        Data layer
    var_names : list
        Protein names
    groupby : str
        Column in obs to group by
    dendrogram : bool
        Show dendrogram
    log : bool
        Log-transform data
    cmap : str
        Colormap
    dot_size : float
        Base dot size
    standard_scale : str or None
        Standardize across 'var' or 'obs'
    show : bool
        Show plot
    ax : Axes or None
        Matplotlib axes
    **kwargs
        Additional arguments

    Returns
    -------
    Axes
        Matplotlib axes
    """
    validate_container(container)
    validate_layer(container, "proteins", layer)
    validate_features(container, "proteins", var_names)
    validate_groupby(container, groupby)

    PlotStyle.apply_style()

    assay = container.assays["proteins"]
    X = assay.layers[layer].X.copy()

    # Filter to selected features
    feature_idx = [i for i, p in enumerate(assay.var["protein"]) if p in var_names]
    X = X[:, feature_idx]

    # Log transform
    if log:
        X = np.log1p(X)

    # Get groups
    groups = container.obs[groupby].to_numpy()
    unique_groups = np.unique(groups)

    # Calculate mean expression per group
    mean_expr = np.zeros((len(unique_groups), len(var_names)))
    pct_expr = np.zeros_like(mean_expr)

    for i, g in enumerate(unique_groups):
        mask = groups == g
        group_data = X[mask]
        mean_expr[i] = group_data.mean(axis=0)
        pct_expr[i] = (group_data > 0).mean(axis=0)

    # Standardize
    if standard_scale == "var":
        mean_expr = (mean_expr - mean_expr.min(axis=0)) / (mean_expr.max(axis=0) - mean_expr.min(axis=0) + 1e-8)

    # Create plot
    if ax is None:
        fig, ax = plt.subplots(figsize=(2 + len(var_names) * 0.5, 2 + len(unique_groups) * 0.5))

    # Draw dots
    for i, g in enumerate(unique_groups):
        for j, var in enumerate(var_names):
            size = pct_expr[i, j] * dot_size * 20
            color = mean_expr[i, j]
            ax.scatter(j + 0.5, i + 0.5, s=size, c=[[color]], cmap=cmap, vmin=0, vmax=1, edgecolors="black", linewidth=0.5)

    ax.set_yticks(np.arange(len(unique_groups)) + 0.5)
    ax.set_yticklabels(unique_groups)
    ax.set_xticks(np.arange(len(var_names)) + 0.5)
    ax.set_xticklabels(var_names, rotation=45, ha="right")
    ax.set_xlim(0, len(var_names))
    ax.set_ylim(0, len(unique_groups))
    ax.set_ylabel(groupby)
    ax.invert_yaxis()

    # Colorbar
    sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=0, vmax=1))
    sm.set_array([])
    cbar = plt.colorbar(sm, ax=ax, label="Mean expression")

    if show:
        plt.tight_layout()
        plt.show()

    return ax
```

**Step 4: Run tests to verify they pass**

```bash
uv run pytest tests/test_viz/test_recipes/test_feature.py::test_dotplot_basic -v
```
Expected: PASS

**Step 5: Commit**

```bash
git add scptensor/viz/recipes/feature.py tests/test_viz/test_recipes/test_feature.py
git commit -m "feat(viz): add dotplot function"
```

---

## Summary of Remaining Phases

Due to document length, remaining phases follow the same pattern:

**Phase 4: Matrix Visualization** - `matrixplot`, `heatmap`, `tracksplot`
**Phase 5: Differential Expression** - `rank_genes_groups_*`, `volcano`
**Phase 6: QC & Statistics** - `pca_overview`, `missing_value_patterns`, `correlation_matrix`, `dendrogram`

Each follows TDD: write test → run (fail) → implement → run (pass) → commit.

---

**Document Version:** 1.0
**Last Updated:** 2026-01-14
**Estimated Total Tasks:** ~40-50 tasks across 6 phases
**Estimated Duration:** 3-4 weeks of focused development
